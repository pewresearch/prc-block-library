{"version":3,"file":"view.js","mappings":"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","sources":["webpack://@prc/block-library/./src/dialog-element/view.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport {\n\tstore,\n\tgetContext,\n\tgetElement,\n\twithScope,\n\twithSyncEvent,\n} from '@wordpress/interactivity';\n\nfunction addDialogIdToUrl( id ) {\n\tconst url = new URL( window.location.href );\n\turl.searchParams.set( 'dialogId', id );\n\t// Update the URL without adding to history\n\twindow.history.replaceState( {}, '', url );\n}\n\nfunction removeDialogIdFromUrl() {\n\tconst url = new URL( window.location.href );\n\tconsole.log('removeDialogIdFromUrl fired, current URL:', url.toString());\n\turl.searchParams.delete( 'dialogId' );\n\tconsole.log('Updated URL after removing dialogId:', url.toString());\n\t// Update the URL without adding to history\n\twindow.history.replaceState( {}, '', url );\n}\n\nconst { actions, state } = store( 'prc-block/dialog', {\n\tstate: {\n\t\tget id() {\n\t\t\tconst context = getContext();\n\t\t\treturn context?.id;\n\t\t},\n\t\tget dialog() {\n\t\t\treturn state.dialogs[ state.id ];\n\t\t},\n\t\tget dialogElement() {\n\t\t\tconst context = getContext();\n\t\t\tif ( ! context?.id ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst { id } = context;\n\t\t\treturn document.getElementById( id );\n\t\t},\n\t},\n\tactions: {\n\t\t/**\n\t\t * Helper function to close all open dialogs.\n\t\t */\n\t\tcloseAll: () => {\n\t\t\tconst { dialogs } = state;\n\t\t\tconst ids = Object.keys( dialogs );\n\t\t\tids.forEach( ( id ) => {\n\t\t\t\t// Check that state[key] is an object and has an isOpen property.\n\t\t\t\tif (\n\t\t\t\t\ttypeof dialogs[ id ] !== 'object' ||\n\t\t\t\t\t! dialogs[ id ].hasOwnProperty( 'isOpen' )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstate.dialogs[ id ].isOpen = false;\n\t\t\t} );\n\t\t},\n\t\t/**\n\t\t * This function is used by dialog-trigger to open the dialog when clicked.\n\t\t * @param event\n\t\t */\n\t\tonClickOpen: withSyncEvent( ( event ) => {\n\t\t\t// We are hijacking all clicks on the trigger and any children to prevent the default click behavior.\n\t\t\tconsole.log('onClickOpen fired');\n\t\t\tevent.preventDefault();\n\t\t\tconst { id } = state;\n\t\t\tactions.open( id );\n\t\t} ),\n\t\t/**\n\t\t * This function is used by the close button in the dialog element, when clicked it closes the dialog.\n\t\t * @param event\n\t\t */\n\t\tonClickClose: withSyncEvent( ( event ) => {\n\t\t\tevent.preventDefault();\n\t\t\tconst { id } = state;\n\t\t\tactions.close( id );\n\t\t} ),\n\t\t/**\n\t\t * This function allows you to directly open a dialog by passing an id from another store, like so:\n\t\t * store('core/dialog').actions.open('xyz123');\n\t\t * @param {*} passthroughId\n\t\t */\n\t\topen: ( passthroughId = false ) => {\n\t\t\t// Most interactions will pass an id through, but if not then fallback to state for id.\n\t\t\tlet id = passthroughId;\n\t\t\tif ( ! id ) {\n\t\t\t\tid = state.id;\n\t\t\t}\n\t\t\t// Finally, if there is no id then we can't proceed and should exit early.\n\t\t\tif ( ! id ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate.dialogs[ id ].isOpen = true;\n\t\t\tstate.dialogs[ id ].closingModal = false;\n\t\t},\n\t\t/**\n\t\t * This function allows you to directly close a dialog by passing an id from another store, like so:\n\t\t * store('core/dialog').actions.close('xyz123');\n\t\t * @param {*} passthroughId\n\t\t */\n\t\tclose: ( passthroughId = false ) => {\n\t\t\tlet id = passthroughId;\n\t\t\tif ( ! id ) {\n\t\t\t\tid = state.id;\n\t\t\t}\n\t\t\tif ( ! id ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate.dialogs[ id ].isOpen = false;\n\t\t},\n\t},\n\tcallbacks: {\n\t\t/**\n\t\t * Handles the escape key event to close the dialog if it's open.\n\t\t *\n\t\t * @param event The keyboard event.\n\t\t */\n\t\tonESCKey: withSyncEvent( ( event ) => {\n\t\t\tconst { id, dialog } = state;\n\t\t\tif ( id && event.key === 'Escape' ) {\n\t\t\t\tif ( true === dialog.isOpen ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tactions.close( id );\n\t\t\t\t}\n\t\t\t}\n\t\t} ),\n\t\t/**\n\t\t * Handles the dialog open event, this is triggered by the user clicking the open button or via an auto activation timer.\n\t\t */\n\t\tonOpen: () => {\n\t\t\tconst { dialogElement, dialog, id } = state;\n\t\t\t// Sanity check, if we don't have an id or dialogElement then we can't proceed.\n\t\t\tif ( ! id || ! dialogElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If the dialog is meant to not be open, don't proceed.\n\t\t\tif ( ! dialog.isOpen ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.log('onOpen fired');\n\t\t\tif ( dialog.enableDeepLink ) {\n\t\t\t\tconsole.log('Adding dialogId to URL:', id);\n\t\t\t\taddDialogIdToUrl( id );\n\t\t\t}\n\t\t\tconsole.log(\"Showing dialog element:\", dialogElement);\n\t\t\tdialogElement?.showModal();\n\t\t},\n\t\t/**\n\t\t * Handles the dialog close event, this is triggered by the user clicking the close button, pressing the escape key or clicking outside the dialog when it's a non-modal dialog.\n\t\t */\n\t\tonClose: () => {\n\t\t\tconst { dialogElement, dialog, id } = state;\n\t\t\t// Sanity check, if we don't have an id or dialogElement then we can't proceed.\n\t\t\tif ( ! id || ! dialogElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If the dialog is meant to be open, don't proceed.\n\t\t\tif ( dialog.isOpen ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If already closing, don't start another close animation\n\t\t\tif ( dialog.isClosing ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// CRITICAL FIX: Only proceed if the dialog element is actually open in the DOM\n\t\t\t// This prevents the watcher from triggering close animations when the dialog\n\t\t\t// was never opened in the first place (e.g., on page load when isOpen initializes to false)\n\t\t\tif ( ! dialogElement.open ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconsole.log('onClose fired');\n\t\t\t// Start isClosing animation...\n\t\t\tstate.dialogs[ id ].isClosing = true;\n\t\t\t// Allow for animation to complete...\n\t\t\tsetTimeout(\n\t\t\t\twithScope( () => {\n\t\t\t\t\tconsole.log(\"Closing dialog element:\", dialogElement);\n\t\t\t\t\tdialogElement?.close();\n\t\t\t\t\tconsole.log('Removing dialogId from URL', id);\n\t\t\t\t\tremoveDialogIdFromUrl( id ); // We always clean the dialog id regardless of whether deep linking is enabled or not.\n\t\t\t\t\tstate.dialogs[ id ].isClosing = false;\n\t\t\t\t\tstate.dialogs[ id ].isOpen = false;\n\t\t\t\t} ),\n\t\t\t\tdialog.animationDuration\n\t\t\t);\n\t\t},\n\t\t/**\n\t\t * Closes the dialog if the backdrop is clicked.\n\t\t *\n\t\t * @param event\n\t\t */\n\t\tonBackdropClick: withSyncEvent( ( event ) => {\n\t\t\tconst { ref } = getElement();\n\t\t\tconst boundingRects = ref.getBoundingClientRect();\n\t\t\t// make sure the event x and y are within the dialog element, if they are continue...\n\t\t\tif (\n\t\t\t\tevent.clientX >= boundingRects.left &&\n\t\t\t\tevent.clientX <= boundingRects.right &&\n\t\t\t\tevent.clientY >= boundingRects.top &&\n\t\t\t\tevent.clientY <= boundingRects.bottom\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst { dialog, id } = state;\n\t\t\tif ( true !== dialog.isOpen || dialog.isClosing ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tactions.close( id );\n\t\t} ),\n\t\t/**\n\t\t * Activates the current dialog element if there is an auto activation timer set.\n\t\t */\n\t\tonAutoActivation: () => {\n\t\t\tconst { id, dialog, dialogs } = state;\n\t\t\tconsole.log('Dialog: init', id);\n\t\t\tif (\n\t\t\t\t! id &&\n\t\t\t\t! dialog.activationTimerDuration &&\n\t\t\t\t-1 !== dialog.activationTimerDuration\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Check if any of the dialogs are already open,\n\t\t\t// if so we don't want to close or auto activate another dialog.\n\t\t\tconst dialogIds = Object.keys( dialogs );\n\t\t\tfor ( let i = 0; i < dialogIds.length; i++ ) {\n\t\t\t\tconst dialogId = dialogIds[ i ];\n\t\t\t\tif ( dialogs[ dialogId ].isOpen ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( 1 <= dialog.activationTimerDuration ) {\n\t\t\t\tsetTimeout(\n\t\t\t\t\twithScope( () => {\n\t\t\t\t\t\tactions.closeAll();\n\t\t\t\t\t\tactions.open( id );\n\t\t\t\t\t} ),\n\t\t\t\t\tdialog.activationTimerDuration\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t},\n} );\n"],"names":["actions","state","store","id","context","getContext","dialog","dialogs","dialogElement","document","getElementById","closeAll","Object","keys","forEach","hasOwnProperty","isOpen","onClickOpen","withSyncEvent","event","console","log","preventDefault","open","onClickClose","close","passthroughId","closingModal","callbacks","onESCKey","key","onOpen","enableDeepLink","url","URL","window","location","href","searchParams","set","history","replaceState","addDialogIdToUrl","showModal","onClose","isClosing","setTimeout","withScope","toString","delete","removeDialogIdFromUrl","animationDuration","onBackdropClick","ref","getElement","boundingRects","getBoundingClientRect","clientX","left","right","clientY","top","bottom","onAutoActivation","activationTimerDuration","dialogIds","i","length"],"sourceRoot":""}